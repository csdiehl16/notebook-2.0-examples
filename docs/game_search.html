<!doctype html>
<notebook theme="glacier">
  <title>Game search</title>
  <script id="1" type="text/markdown">
    # Game search
  </script>
  <script id="2" type="text/x-python" pinned="" output="gameActions" format="json">
    import copy
    import itertools
    import random
    from collections import namedtuple
    import json

    GameState = namedtuple('GameState', 'to_move, utility, board, moves')
    gameActions = []

    def alpha_beta_search(state, game):
        """Search game to determine best action; use alpha-beta pruning.
        As in [Figure 5.7], this version searches all the way to the leaves."""

        player = game.to_move(state)

        # Functions used by alpha_beta
        def max_value(state, alpha, beta):
            if game.terminal_test(state):
                return game.utility(state, player)
            v = float('-inf')
            for a in game.actions(state):
                v = max(v, min_value(game.result(state, a), alpha, beta))
                if v >= beta:
                    return v
                alpha = max(alpha, v)
            return v

        def min_value(state, alpha, beta):
            if game.terminal_test(state):
                return game.utility(state, player)
            v = float('inf')
            for a in game.actions(state):
                v = min(v, max_value(game.result(state, a), alpha, beta))
                if v <= alpha:
                    return v
                beta = min(beta, v)
            return v

        # Body of alpha_beta_search:
        best_score = float('-inf')
        beta = float('inf')
        best_action = None
        for a in game.actions(state):
            v = min_value(game.result(state, a), best_score, beta)
            if v > best_score:
                best_score = v
                best_action = a
        return best_action


    class Game:
        """A game is similar to a problem, but it has a utility for each
        state and a terminal test instead of a path cost and a goal
        test. To create a game, subclass this class and implement actions,
        result, utility, and terminal_test. You may override display and
        successors or you can inherit their default methods. You will also
        need to set the .initial attribute to the initial state; this can
        be done in the constructor."""

        def actions(self, state):
            """Return a list of the allowable moves at this point."""
            raise NotImplementedError

        def result(self, state, move):
            """Return the state that results from making a move from a state."""
            raise NotImplementedError

        def utility(self, state, player):
            """Return the value of this final state to player."""
            raise NotImplementedError

        def terminal_test(self, state):
            """Return True if this is a final state for the game."""
            return not self.actions(state)

        def to_move(self, state):
            """Return the player whose move it is in this state."""
            return state.to_move

        def display(self, state):
            """Print or otherwise display the state."""
            print(state)

        def __repr__(self):
            return '<{}>'.format(self.__class__.__name__)

        def play_game(self, *players):
            """Play an n-person, move-alternating game."""
            state = self.initial
            while True:
                for player in players:
                    move = player(self, state)
                    state = self.result(state, move)
                    if self.terminal_test(state):
                        self.display(state)
                        return self.utility(state, self.to_move(self.initial))


    class TicTacToe(Game):
        """Play TicTacToe on an h x v board, with Max (first player) playing 'X'.
        A state has the player to move, a cached utility, a list of moves in
        the form of a list of (x, y) positions, and a board, in the form of
        a dict of {(x, y): Player} entries, where Player is 'X' or 'O'."""

        def __init__(self, h=3, v=3, k=3):
            self.h = h
            self.v = v
            self.k = k
            moves = [(x, y) for x in range(1, h + 1)
                     for y in range(1, v + 1)]
            self.initial = GameState(to_move='X', utility=0, board={}, moves=moves)

        def actions(self, state):
            """Legal moves are any square not yet taken."""
            return state.moves

        def result(self, state, move):
            if move not in state.moves:
                return state  # Illegal move has no effect
            board = state.board.copy()
            board[move] = state.to_move
            moves = list(state.moves)
            moves.remove(move)
            return GameState(to_move=('O' if state.to_move == 'X' else 'X'),
                             utility=self.compute_utility(board, move, state.to_move),
                             board=board, moves=moves)

        def utility(self, state, player):
            """Return the value to player; 1 for win, -1 for loss, 0 otherwise."""
            return state.utility if player == 'X' else -state.utility

        def terminal_test(self, state):
            """A state is terminal if it is won or there are no empty squares."""
            return state.utility != 0 or len(state.moves) == 0

        def display(self, state):
            board = state.board
            for x in range(1, self.h + 1):
                for y in range(1, self.v + 1):
                    print(board.get((x, y), '.'), end=' ')
                print()

        def compute_utility(self, board, move, player):
            """If 'X' wins with this move, return 1; if 'O' wins return -1; else return 0."""
            if (self.k_in_row(board, move, player, (0, 1)) or
                    self.k_in_row(board, move, player, (1, 0)) or
                    self.k_in_row(board, move, player, (1, -1)) or
                    self.k_in_row(board, move, player, (1, 1))):
                return +1 if player == 'X' else -1
            else:
                return 0

        def k_in_row(self, board, move, player, delta_x_y):
            """Return true if there is a line through move on board for player."""
            (delta_x, delta_y) = delta_x_y
            x, y = move
            n = 0  # n is number of moves in row
            while board.get((x, y)) == player:
                n += 1
                x, y = x + delta_x, y + delta_y
            x, y = move
            while board.get((x, y)) == player:
                n += 1
                x, y = x - delta_x, y - delta_y
            n -= 1  # Because we counted move itself twice
            return n >= self.k


    game = TicTacToe()

    def random_player(game, state):
        """A player that chooses a legal move at random."""
        return random.choice(game.actions(state)) if game.actions(state) else None


    def alpha_beta_player(game, state):
        return alpha_beta_search(state, game)

    def play_game(game):
      state = game.initial
      counter = 0
      # print(game.display(state))

      while (not game.terminal_test(state)):
        move = alpha_beta_player(game, state)
        newState = game.result(state, move)


        # record choices and result
        gameActions.append({"player": ('max' if counter % 2 == 0 else 'min') , "actions": game.actions(state), 'move': move, 'utility': newState.utility})

        state = newState
        counter += 1

        # print(game.display(state))

    play_game(game)
    print(json.dumps(gameActions))
  </script>
  <script id="3" type="module" pinned="">
    // Create a tree visualization of the alpha-beta search
    const width = 800;
    const height = 600;
    const margin = {top: 20, right: 20, bottom: 20, left: 20};

    // Process the game actions data to create a tree structure
    function buildTree(gameActions) {
      const root = {
        id: 'root',
        player: 'start',
        move: null,
        actions: gameActions[0]?.actions || [],
        children: []
      };

      let currentNode = root;
      const nodeMap = new Map();
      nodeMap.set('root', root);

      gameActions.forEach((action, index) => {
        const nodeId = `node_${index}`;
        const node = {
          id: nodeId,
          player: action.player,
          move: action.move,
          actions: action.actions,
          children: action.actions
        };

        currentNode.children.push(node);
        nodeMap.set(nodeId, node);
        currentNode = node;
      });

      return root;
    }

    const treeData = buildTree(gameActions);

    // Create the SVG
    const svg = d3.create("svg")
        .attr("width", width)
        .attr("height", height)
        .attr("viewBox", [0, 0, width, height]);

    // Create a tree layout
    const treeLayout = d3.tree()
        .size([width - margin.left - margin.right, height - margin.top - margin.bottom]);

    // Create hierarchy from the data
    const hierarchy = d3.hierarchy(treeData);
    const treeNodes = treeLayout(hierarchy);

    // Create a group for the tree
    const g = svg.append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

    // Add links (edges)
    g.selectAll(".link")
        .data(treeNodes.links())
        .enter().append("path")
        .attr("class", "link")
        .attr("d", d3.linkVertical()
            .x(d => d.x)
            .y(d => d.y))
        .attr("fill", "none")
        .attr("stroke", "#ccc")
        .attr("stroke-width", 2);

    // Add nodes
    const node = g.selectAll(".node")
        .data(treeNodes.descendants())
        .enter().append("g")
        .attr("class", "node")
        .attr("transform", d => `translate(${d.x},${d.y})`);

    // Add circles for nodes
    node.append("circle")
        .attr("r", 8)
        .attr("fill", d => {
          if (d.data.player === 'start') return "#666";
          return d.data.player === 'max' ? "#4CAF50" : "#F44336";
        })
        .attr("stroke", "#fff")
        .attr("stroke-width", 2);

    // Add labels for moves
    node.append("text")
        .attr("dy", -12)
        .attr("text-anchor", "middle")
        .style("font-size", "12px")
        .style("font-family", "monospace")
        .text(d => {
          if (d.data.move) {
            return `(${d.data.move[0]},${d.data.move[1]})`;
          }
          return d.data.player === 'start' ? 'Start' : '';
        });

    // Add player labels
    node.append("text")
        .attr("dy", 20)
        .attr("text-anchor", "middle")
        .style("font-size", "10px")
        .style("font-family", "sans-serif")
        .style("fill", "#666")
        .text(d => d.data.player === 'start' ? '' : d.data.player);

    // Add title
    svg.append("text")
        .attr("x", width / 2)
        .attr("y", 15)
        .attr("text-anchor", "middle")
        .style("font-size", "16px")
        .style("font-weight", "bold")
        .text("Alpha-Beta Search Game Tree");

    // Add legend
    const legend = svg.append("g")
        .attr("transform", `translate(${width - 150}, 30)`);

    legend.append("circle")
        .attr("cx", 0)
        .attr("cy", 0)
        .attr("r", 6)
        .attr("fill", "#4CAF50");

    legend.append("text")
        .attr("x", 12)
        .attr("y", 4)
        .style("font-size", "12px")
        .text("Max player");

    legend.append("circle")
        .attr("cx", 0)
        .attr("cy", 20)
        .attr("r", 6)
        .attr("fill", "#F44336");

    legend.append("text")
        .attr("x", 12)
        .attr("y", 24)
        .style("font-size", "12px")
        .text("Min player");

    display(svg.node());
  </script>
</notebook>
