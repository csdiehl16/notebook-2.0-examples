<!doctype html>
<notebook theme="air">
  <title>K-means clustering with 3D scatterplot</title>
  <script id="1" type="text/markdown">
    # K-means clustering with 3D scatterplot
  </script>
  <script id="2" type="module" pinned="">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.181.2/+esm';

    // Create container
    const height = 600
    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);

    const X = "culmen_depth_mm", Y = "culmen_length_mm", Z = "body_mass_g"

    // create scales
    const x = d3.scaleLinear(d3.extent(data, d => d[X]), [0,20])
    const y = d3.scaleLinear(d3.extent(data, d => d[Y]), [0,20])
    const z = d3.scaleLinear(d3.extent(data, d => d[Z]), [0,20])

    // Camera setup
    const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
    camera.position.set(20, 15, 35);
    camera.lookAt(0,0,0)

    // Renderer setup
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(width, height);

    // Generate sample data points
    const numPoints = 100;
    const points = data.map(d => {
      return {
        x: x(d[X]), y: y(d[Y]), z: z(d[Z]), color: '#000000'
      }
    })

    // Create point geometry and materials
    const geometry = new THREE.SphereGeometry(0.15, 8, 8);
    const pointMeshes = [];

    points.forEach(point => {
      const material = new THREE.MeshBasicMaterial({ color: point.color });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(point.x, point.y, point.z);
      scene.add(mesh);
      pointMeshes.push(mesh);
    });

    // Add coordinate axes
    const axesHelper = new THREE.AxesHelper(30);
    axesHelper.setColors('#ccc', '#ccc', '#ccc')
    scene.add(axesHelper);

    // Add grid
    const gridHelper = new THREE.GridHelper(40, 40, 0x888888, 0xcccccc);
    scene.add(gridHelper);

    // Animation loop
    function animate() {
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    animate();

    // Cleanup on cell re-run
    invalidation.then(() => {
      renderer.dispose();
      geometry.dispose();
      pointMeshes.forEach(mesh => {
        mesh.material.dispose();
      });
    });

    display(renderer.domElement)
  </script>
  <script id="3" type="text/x-typescript" pinned="">
    const data = penguins
    display(Inputs.table(data.slice(0,10)))
  </script>
  <script id="4" type="text/x-python" pinned="" format="json">
    import numpy as np
    from scipy.cluster.vq import kmeans, vq, whiten

    # 1. Generate sample data
    # Let's create some synthetic data with 3 distinct clusters
    data = np.vstack((
        np.random.rand(100, 2) * 0.5 + np.array([0, 0]),
        np.random.rand(100, 2) * 0.5 + np.array([2, 2]),
        np.random.rand(100, 2) * 0.5 + np.array([0, 2])
    ))

    # 2. Whiten the data
    # Whitening scales each feature to have zero mean and unit variance.
    # This is often recommended before applying K-Means.
    whitened_data = whiten(data)

    # 3. Perform K-Means clustering
    # We specify the number of clusters (k) and get the centroids (codebook)
    # and the distortion (sum of squared distances from observations to their nearest centroid).
    k = 3  # Number of clusters
    codebook, distortion = kmeans(whitened_data, k)

    # 4. Assign observations to clusters
    # vq assigns each observation to its nearest centroid, returning the cluster labels
    # and the distances to those centroids.
    cluster_labels, distances = vq(whitened_data, codebook)
  </script>
</notebook>
