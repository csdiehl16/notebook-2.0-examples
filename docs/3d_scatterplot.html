<!doctype html>
<notebook theme="air">
  <title>K-means clustering with 3D scatterplot</title>
  <script id="1" type="text/markdown">
    # K-means clustering with 3D scatterplot

    This notebook demonstrates k-means clustering using a python data loader, with a 3D visualization of the resulting clusters in Three.js. It shows a sample dataset of wines clustered by attributes such as alcohol content and pH.
  </script>
  <script id="2" type="module" pinned="">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.181.2/+esm";
    import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.181.2/examples/jsm/controls/OrbitControls/+esm";

    const data = wine_labeled;
    const X = "fixed acidity",
        Y = "pH",
        Z = "alcohol";

    // Create container
    const height = 600;
    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);

    // create scales
    const x = d3.scaleLinear(
        d3.extent(data, (d) => d[X]),
        [0, 20],
    );
    const y = d3.scaleLinear(
        d3.extent(data, (d) => d[Y]),
        [0, 20],
    );
    const z = d3.scaleLinear(
        d3.extent(data, (d) => d[Z]),
        [0, 20],
    );
    const c = d3.scaleOrdinal(new Set(data.map((d) => d.cluster)), [
        "#121212",
        "orange",
        "steelblue",
    ]);

    // Camera setup
    const camera = new THREE.PerspectiveCamera(
        50,
        width / height,
        0.1,
        1000,
    );
    camera.position.set(20, 15, 35);
    camera.lookAt(0, 0, 0);

    // Renderer setup
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(width, height);

    // Generate sample data points
    const numPoints = 100;
    const points = data.map((d) => {
        return {
            x: x(d[X]),
            y: y(d[Y]),
            z: z(d[Z]),
            color: c(d.cluster),
        };
    });

    // Create point geometry and materials
    const geometry = new THREE.SphereGeometry(0.15, 8, 8);
    const pointMeshes = [];

    points.forEach((point) => {
        const material = new THREE.MeshBasicMaterial({
            color: point.color,
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(point.x, point.y, point.z);
        scene.add(mesh);
        pointMeshes.push(mesh);
    });

    // Add coordinate axes
    const axesHelper = new THREE.AxesHelper(30);
    axesHelper.setColors("#ccc", "#ccc", "#ccc");
    scene.add(axesHelper);

    // Add grid
    const gridHelper = new THREE.GridHelper(40, 40, 0x888888, 0xcccccc);
    scene.add(gridHelper);

    const controls = new OrbitControls(camera, renderer.domElement);

    // Animation loop
    function animate() {
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
    }

    animate();

    // Cleanup on cell re-run
    invalidation.then(() => {
        renderer.dispose();
        geometry.dispose();
        pointMeshes.forEach((mesh) => {
            mesh.material.dispose();
        });
    });

    display(renderer.domElement);
  </script>
  <script id="9" type="text/x-typescript">
    Inputs.table(wine_labeled)
  </script>
  <script id="4" type="text/x-python" pinned="" output="wine_labeled" format="json">
    import numpy as np
    from scipy.cluster.vq import kmeans, vq, whiten
    import pandas as pd
    import json

    df = pd.read_json('data/WineQT.json')

    feat = df[['alcohol', 'pH', 'fixed acidity']]

    whitened_data = whiten(feat)

    k = 3  # Number of clusters
    codebook, distortion = kmeans(whitened_data, k)

    cluster_labels, distances = vq(whitened_data, codebook)

    df['cluster'] = cluster_labels
    df['distance_to_centroid'] = distances

    result = df.to_dict('records')
    print(json.dumps(result))
  </script>
</notebook>
